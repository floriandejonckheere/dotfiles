#!/usr/bin/env zsh

# URL for the NephroFlow API server
export NF_SERVER=http://localhost:3000

# Path to directory containing the repositories
export NF_PATH=~/Code

# Database prefix
export NF_DB_PREFIX=nephroflow_

# cURL options
declare -a NF_CURL_OPTIONS
export NF_CURL_OPTIONS=(--silent --fail --show-error)

##
# Helper functions
#

# Compose wrapper
function nf_compose() {
  COMPOSE_FILE="${NF_PATH}/nephroflow-api/compose.yaml"

  if [[ ! -f ${COMPOSE_FILE} ]]; then
    COMPOSE_FILE="${NF_PATH}/nephroflow-api/docker-compose.yml"
  fi

  if [[ ! -f ${COMPOSE_FILE} ]]; then
    echo "Error: ${COMPOSE_FILE} not found"

    return
  fi

  docker compose -f "${COMPOSE_FILE}" "${@}"
}

# Run a command until it fails
function until_fail() {
  while "$@"; do :; done
}

##
# Configuration functions
#

# Set default API server (default: http://localhost:3000)
function nf_server() {
  SERVER=${1:-http://localhost:3000}

  export NF_SERVER=${SERVER}

  echo "API server set to ${SERVER}"
}

function nf_path() {
  _PATH=${1:-~/Code}

  export NF_PATH=${_PATH}

  echo "Repositories path set to ${_PATH}"
}

# Set default database prefix (default: nephroflow_)
function nf_db_prefix() {
  PREFIX=${1:-nephroflow_}

  export NF_DB_PREFIX=${PREFIX}

  echo "Database prefix set to ${PREFIX}"
}

# Set default curl options (default: --silent --show-error)
function nf_curl_options() {
  NF_CURL_OPTIONS=(${=@:-"--silent" "--fail" "--show-error"})

  echo "cURL options set to ${NF_CURL_OPTIONS[*]}"
}

# Strip the API server from the URL
function nf_url() {
  URL=${1}

  if [[ ! ${URL} ]]; then
    echo "Usage: ${0} URL"

    return 1
  fi

  # Strip protocol, ://, hostname, port, and /api
  URL=$(echo "${URL}" | sed -E 's/^\s*(.*:\/\/)?[^\/]*\/?api\/?//g')

  echo "${URL}"
}

##
# Authentication functions
#

# Sign in as a user and set token environment variables (default username: henry.davidson)
function nf_signin() {
  USER=${1:-henry.davidson}
  PASSWORD=${2:-password}
  OPTIONS=(${@:3})

  BODY=$(curl ${OPTIONS} ${NF_CURL_OPTIONS} -X POST \
    -d "{\"username\": \"${USER}\", \"password\": \"${PASSWORD}\"}" \
    -H 'Content-Type: application/json' \
    ${NF_SERVER}/api/auth)

  if [[ $(echo "${BODY}" | jq '.errors') != "null" ]]; then
    echo "Error signing in: $(echo "${BODY}" | jq -r '.errors[0].title')"

    return
  fi

  REFRESH_TOKEN=$(echo "${BODY}" | jq -r '.refresh')
  export REFRESH_TOKEN

  ACCESS_TOKEN=$(echo "${BODY}" | jq -r '.access')
  export ACCESS_TOKEN

  echo "Signed in as ${USER} (valid until $(echo "${BODY}" | jq -r '.refresh_expires_at'))"
}

# Sign out and clear token environment variables
function nf_signout() {
  OPTIONS=(${@})

    if [[ ! ${REFRESH_TOKEN} ]]; then
      echo "Error: REFRESH_TOKEN not set"

      return
    fi

  BODY=$(curl ${OPTIONS} ${NF_CURL_OPTIONS} -X DELETE \
    -H 'Content-Type: application/json' \
    -H "X-Refresh-Token: ${REFRESH_TOKEN}" \
    ${NF_SERVER}/api/auth)

  if [[ $? -eq 22 ]]; then
    echo "Error signing out"

    return
  fi

  unset ACCESS_TOKEN
  unset REFRESH_TOKEN

  echo "Signed out"
}

# Refresh the access token using the refresh token
function nf_refresh() {
  OPTIONS=(${@})

  if [[ ! ${REFRESH_TOKEN} ]]; then
    echo "Error: REFRESH_TOKEN not set"

    return
  fi

  BODY=$(curl ${OPTIONS} ${NF_CURL_OPTIONS} -X POST \
    -H 'Content-Type: application/json' \
    -H "X-Refresh-Token: ${REFRESH_TOKEN}" \
    ${NF_SERVER}/api/auth/refresh)

  if [[ $(echo "${BODY}" | jq '.errors') != "null" ]]; then
    echo "Error refreshing token"

    return
  fi

  ACCESS_TOKEN=$(echo "${BODY}" | jq -r '.access')
  export ACCESS_TOKEN

  echo "Refreshed access token (valid until $(echo "${BODY}" | jq -r '.access_expires_at'))"
}

# Find or create an integration token and set token environment variables (default scope: link)
function nf_token() {
  SCOPE=${1:-"link"}
  NAME="${SCOPE}-${RANDOM}"

  # Sign in as administrator
  nf_signin nephroflow admin &> /dev/null

  # Find or create integration token
  TOKEN=$(nf_post \
    ${NF_SERVER}/api/users/integration_tokens \
    "{\"name\":\"${NAME}\",\"scope\":\"${SCOPE}\",\"expiration_period\":\"1_month\"}" \
    | jq -r '.token')

  EXPIRATION=$(nf_get /api/users/integration_tokens | jq -r ".integration_tokens[] | select(.name == \"${NAME}\") | .expiration_at")

  ACCESS_TOKEN=${TOKEN}
  export ACCESS_TOKEN

  echo "Created integration token with scope ${SCOPE} (valid until ${EXPIRATION})"
}

##
# HTTP functions
#

# GET a resource
function nf_get() {
  URL_PATH=$(nf_url "${1}")
  OPTIONS=(${@:2})

  if [[ ! ${URL_PATH} ]]; then
    echo "Usage: ${0} URL_PATH [OPTIONS...]"

    return 1
  fi

  curl ${OPTIONS} ${NF_CURL_OPTIONS} -X GET \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    ${NF_SERVER}/api/${URL_PATH} | jq
}

# POST a resource
function nf_post() {
  URL_PATH=$(nf_url "${1}")
  BODY=${2}
  OPTIONS=(${@:3})

  if [[ ! ${BODY} ]]; then
    echo "Usage: ${0} URL_PATH JSON_BODY [OPTIONS...]"

    return 1
  fi

  curl ${OPTIONS} ${NF_CURL_OPTIONS} -X POST \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "${BODY}" \
    ${NF_SERVER}/api/${URL_PATH} | jq
}

# PATCH a resource
function nf_patch() {
  URL_PATH=$(nf_url "${1}")
  BODY=${2}
  OPTIONS=(${@:3})

  if [[ ! ${BODY} ]]; then
    echo "Usage: ${0} URL_PATH JSON_BODY [OPTIONS...]"

    return 1
  fi

  curl ${OPTIONS} ${NF_CURL_OPTIONS} -X PATCH \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "${BODY}" \
    ${NF_SERVER}/api/${URL_PATH} | jq
}

function nf_delete() {
  URL_PATH=$(nf_url "${1}")
  OPTIONS=(${@:2})

  if [[ ! ${URL_PATH} ]]; then
    echo "Usage: ${0} URL_PATH [OPTIONS...]"

    return 1
  fi

  curl ${OPTIONS} ${NF_CURL_OPTIONS} -X DELETE \
    -H "Authorization: Bearer ${ACCESS_TOKEN}" \
    ${NF_SERVER}/api/${URL_PATH} | jq
}

##
# Database functions
#

# Connect to production database
function nf_db_connect_prod() {
  PGPASSWORD=${PG_PASSWORD} psql -h ${PG_HOST} -p ${PG_PORT} -U ${PG_USERNAME} -d ${PG_DATABASE}
}

# Open a database console
function nf_db() {
  nf_compose exec postgres psql -P pager -U postgres "${@}"
}

# List databases
function nf_db_ls() {
  nf_db -c "\l"
}

# Terminate all connections to a database
function nf_db_terminate() {
  DATABASE=${1:-development}

  # Remove prefix
  DATABASE=${DATABASE#"${NF_DB_PREFIX}"}

  nf_db -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid <> pg_backend_pid() AND datname='${NF_DB_PREFIX}${DATABASE}'" > /dev/null

  echo "Connections to ${NF_DB_PREFIX}${DATABASE} terminated"
}

# Create a database
function nf_db_create() {
  if [[ ! ${!} ]]; then
    echo "Usage: ${0} DATABASE ..."

    return 1
  fi

  for DATABASE in "${@}"; do
    nf_db -c "CREATE DATABASE ${NF_DB_PREFIX}${DATABASE}" > /dev/null

    echo "Database ${NF_DB_PREFIX}${DATABASE} created"
  done
}

# Drop a database
function nf_db_drop() {
  if [[ ! ${1} ]]; then
    echo "Usage: ${0} DATABASE ..."

    return 1
  fi

  for DATABASE in "${@}"; do
    # Remove prefix
    DATABASE=${DATABASE#"${NF_DB_PREFIX}"}

    nf_db -c "DROP DATABASE ${NF_DB_PREFIX}${DATABASE}" > /dev/null

    echo "Database ${NF_DB_PREFIX}${DATABASE} dropped"
  done
}

# Rename a database
function nf_db_rename() {
  # Remove prefix
  OLD_DATABASE=${1#"${NF_DB_PREFIX}"}
  NEW_DATABASE=${2#"${NF_DB_PREFIX}"}

  if [[ ! ${OLD_DATABASE} || ! ${NEW_DATABASE} ]]; then
    echo "Usage: ${0} OLD_DATABASE NEW_DATABASE"

    return 1
  fi

  nf_db -c "ALTER DATABASE ${NF_DB_PREFIX}${OLD_DATABASE} RENAME TO ${NF_DB_PREFIX}${NEW_DATABASE}" > /dev/null

  echo "Database ${NF_DB_PREFIX}${OLD_DATABASE} renamed to ${NF_DB_PREFIX}${NEW_DATABASE}"
}

# Copy a database
function nf_db_copy() {
  # Remove prefix
  OLD_DATABASE=${1#"${NF_DB_PREFIX}"}
  NEW_DATABASE=${2#"${NF_DB_PREFIX}"}

  if [[ ! ${OLD_DATABASE} || ! ${NEW_DATABASE} ]]; then
    echo "Usage: ${0} OLD_DATABASE NEW_DATABASE"

    return 1
  fi

  nf_db -c "CREATE DATABASE ${NF_DB_PREFIX}${NEW_DATABASE} TEMPLATE ${NF_DB_PREFIX}${OLD_DATABASE}" > /dev/null

  echo "Database ${NF_DB_PREFIX}${OLD_DATABASE} copied to ${NF_DB_PREFIX}${NEW_DATABASE}"
}

# Dump a database to a file
function nf_db_dump() {
  # Remove prefix
  DATABASE=${1#"${NF_DB_PREFIX}"}
  DATABASE=${DATABASE:-development}

  FILE=${2:-${NF_DB_PREFIX}${DATABASE}}
  FILE="${FILE%.sql}.sql.gz"

  if [[ ! ${DATABASE} ]]; then
    echo "Usage: ${0} DATABASE [FILE]"

    return 1
  fi

  nf_compose exec postgres pg_dump -U postgres "${NF_DB_PREFIX}${DATABASE}" | gzip > "${FILE}"

  echo "Database ${NF_DB_PREFIX}${DATABASE} dumped to ${FILE}"
}

# Load a database from a file
nf_db_load() {
  # Remove prefix
  DATABASE=${1#"${NF_DB_PREFIX}"}
  DATABASE=${DATABASE:-development}

  FILE=${2:-${NF_DB_PREFIX}${DATABASE}}
  FILE="${FILE%.sql}.sql.gz"

  if [[ ! ${DATABASE} ]]; then
    echo "Usage: ${0} DATABASE [FILE]"

    return 1
  fi

  gunzip -c "${FILE}" | nf_compose exec -T postgres psql -U postgres "${NF_DB_PREFIX}${DATABASE}" > /dev/null

  echo "Database ${NF_DB_PREFIX}${DATABASE} loaded from ${FILE}"
}

# Create a datestamped snapshot of a database
function nf_db_snapshot() {
  # NephroFlow major version
  VERSION=$(sed -nE 's/ *DEV_VERSION = "([0-9]*)\.[0-9]*\.[0-9]*.*"/\1/p' "${NF_PATH}/nephroflow-api/lib/nephroflow/version.rb")

  # Remove prefix
  DATABASE=${1#"${NF_DB_PREFIX}"}
  DATABASE=${DATABASE:-development}

  nf_db_copy "${DATABASE}" "${DATABASE}_${VERSION}_$(date +%Y%m%d)" > /dev/null

  echo "Database ${NF_DB_PREFIX}${DATABASE} snapshot ${DATABASE}_${VERSION}_$(date +%Y%m%d) created"
}

##
# Docker functions
#

# Start the API server
function nf_api() {
  nf_compose run --rm --service-ports web rails s -b 0.0.0.0
}

# Open a shell
function nf_shell() {
  nf_compose run --rm web bash
}

# Open a Rails console
function nf_console() {
  nf_compose run --rm web rails c
}

# Start the Manager
function nf_manager() {
  BRANCH=${1}

  (
    cd "${NF_PATH}/nephroflow-manager" || return
    [[ ${BRANCH} ]] && (git checkout ${BRANCH}; git pull --ff-only)
    corepack pnpm install
    corepack pnpm run dev
  )
}

##
# Development functions
#

# Autocorrect RuboCop offenses in changed files (staged only)
function nf_diffcop() {
  git diff --staged --name-only | grep '\.rb$' | xargs rubocop --autocorrect-all --force-exclusion
}

# Autocorrect RuboCop offenses in changed files (compared to master)
function nf_maincop() {
  git diff-tree -r --no-commit-id --name-only $(git_main_branch)@\{u\} head | xargs ls -1 2>/dev/null | xargs rubocop --autocorrect-all --force-exclusion
}

##
# Teleport functions
#

# Request authorization
function nf_tsh_auth() {
  REASON=${1}
  ROLE=${2:-"customer-access"} # customer-access, demo-access

  if [[ ! ${REASON} || ! ${ROLE} ]]; then
    echo "Usage: ${0} REASON ROLE"

    return 1
  fi

  tsh login --request-roles="${ROLE}" --request-reason="${REASON}"
}

# Port forward to a remote host
function nf_tsh_forward() {
  HOST=${1}
  PORT=${2}
  LOCALPORT=$((8000 + PORT))

  if [[ ! ${HOST} || ! ${PORT} ]]; then
    echo "Usage: ${0} HOST PORT"

    return 1
  fi

  echo "Connecting to ${HOST}:${PORT}"

  tsh ssh -L 127.0.0.1:${LOCALPORT}:127.0.0.1:${PORT} nephroflow@${HOST}
}
